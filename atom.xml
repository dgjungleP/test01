<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>16&#39;s houese</title>
  
  <subtitle>这是一个猫奴的吸猫场所</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://abc.16home.top/"/>
  <updated>2020-03-18T02:19:46.252Z</updated>
  <id>http://abc.16home.top/</id>
  
  <author>
    <name>Jungle Deng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java8流库学习（一）</title>
    <link href="http://abc.16home.top/javaStream/"/>
    <id>http://abc.16home.top/javaStream/</id>
    <published>2020-03-17T13:51:22.000Z</published>
    <updated>2020-03-18T02:19:46.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>​        流操作是我们在java编程中处理中的一种常用手法，其主要给我们提供的是一种可以在比集合更高级别的上指定计算的数据试图。在流操作中遵循者“做什么而非怎么做”的原则。对于流的操作我们基本上是包含三个步骤：</p><ol><li>创建一个流。</li><li>.指定将初始化流转换为其他流的中间操作，可能包含了多个步骤。</li><li>应用终止操作，从而残生结果。这个操作会强制执行之前的惰性操作。从此以后这个流就再也不能被使用。</li></ol><p>​        在我们接触流之前我们先比较一下流操作与迭代操作的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String sanguo = <span class="keyword">new</span> String(Files.readAllBytes(Paths.get(<span class="string">"sanguo.txt"</span>)), StandardCharsets.UTF_8);</span><br><span class="line"><span class="comment">//计算三国里面每一句超过五个字的段落有多少个</span></span><br><span class="line">List&lt;String&gt; words = Arrays.asList(sanguo.split(<span class="string">"[\\，\\。]"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代方案</span></span><br><span class="line"><span class="keyword">long</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (String w : words) &#123;</span><br><span class="line">    <span class="keyword">if</span> (w.length() &gt; <span class="number">5</span>) count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//流处理方案</span></span><br><span class="line"><span class="keyword">long</span> stremCount = words.stream()</span><br><span class="line">        .filter(w -&gt; w.length() &gt; <span class="number">5</span>)</span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure><p>以上我们可以看到就这样一个小小的要求，就可以看出来流库的便利性，并且代码的可读性提升了不少，所以接下来我们一起来学习一下如何去创建一个流。</p><h2 id="二、流的创建"><a href="#二、流的创建" class="headerlink" title="二、流的创建"></a>二、流的创建</h2><p>​        从上面的方法我们可以看到，流可以通过Collection接口的stream方法将任何的集合转换为一个流。但是当你有一个数组的时候，那么就需要利用静态方法Stream.of方法来创建一个数组的流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(sanguo.split(<span class="string">"[，。]"</span>));</span><br></pre></td></tr></table></figure><p>当然由于Stream.of方法有用一个可变长参数，所以我们也可以香气中传入任意数量引元的流，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = Stream.of(<span class="string">"hello"</span>,<span class="string">"my"</span>,<span class="string">"name"</span>,<span class="string">"is"</span>,<span class="string">"jungle"</span>);</span><br></pre></td></tr></table></figure><p>当然关于数据的创建我们也可以选择数组中自己需要的部分作为引元，利用Array.stream(after,from,of)也可以创建这样的一个流。</p><p>也可以创建一个不包含任何元素的空流利用Stream.empty方法。</p><p>创建流的方法有很多中，其中还包括了无限流的创建，具体Api可以参考Java8手册</p><h2 id="三、流的转化"><a href="#三、流的转化" class="headerlink" title="三、流的转化"></a>三、流的转化</h2><p>​        当我们创建好自己所需要的流之后，我们将对流进行一系列的操作，也就是将原有的流转化为其他形式的流。例如我们上面说到的中过滤操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; words = words.stream().filter(w -&gt; w.length() &gt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>这些列操作包括map、fileter、flatMap。他们可以将你的原有流进行转化，例如一下操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stringStream = words.stream().map(String::toUpperCase);</span><br><span class="line">Stream&lt;String&gt; stringStream = words.stream().flatmap(String::toUpperCase);</span><br></pre></td></tr></table></figure><p>其中flatmap是将流运算过程中所有的元素链接在一起，无论怎么转化都只会得到一个流，例如将以下数组扁平化为一个一维数组，则我们就需要使用到flatmap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String[][] chars = &#123;&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;, &#123;<span class="string">"a"</span>, <span class="string">"v"</span>, <span class="string">"e"</span>&#125;, &#123;<span class="string">"c"</span>, <span class="string">"a"</span>, <span class="string">"c"</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;​        流操作是我们在java编程中处理中的一种常用手法，其主要给我们提供的是一种可以在比集合更高级别的上指定计算
      
    
    </summary>
    
    
      <category term="工具" scheme="http://abc.16home.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="学习" scheme="http://abc.16home.top/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="java" scheme="http://abc.16home.top/categories/%E5%AD%A6%E4%B9%A0/java/"/>
    
      <category term="流操作" scheme="http://abc.16home.top/categories/%E5%B7%A5%E5%85%B7/%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    
    
      <category term="java" scheme="http://abc.16home.top/tags/java/"/>
    
      <category term="lambda" scheme="http://abc.16home.top/tags/lambda/"/>
    
      <category term="流操作" scheme="http://abc.16home.top/tags/%E6%B5%81%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Cache的使用说明</title>
    <link href="http://abc.16home.top/spring-cache/"/>
    <id>http://abc.16home.top/spring-cache/</id>
    <published>2020-03-16T13:16:05.000Z</published>
    <updated>2020-03-16T13:30:28.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>SpringCache本身是一个缓存体系的抽象实现，并没有具体的缓存能力，要使用SpringCache还需要配合具体的缓存实现来完成。</p><p>虽然如此，但是SpringCache是所有Spring支持的缓存结构的基础，而且所有的缓存的使用最后都要归结于SpringCache，那么一来，要想使用SpringCache，还是要仔细研究一下的。</p><h2 id="二、缓存注解"><a href="#二、缓存注解" class="headerlink" title="二、缓存注解"></a>二、缓存注解</h2><p>SpringCache缓存功能的实现是依靠下面的这几个注解完成的。</p><ul><li>@EnableCaching：开启缓存功能</li><li>@Cacheable：定义缓存，用于触发缓存</li><li>@CachePut：定义更新缓存，触发缓存更新</li><li>@CacheEvict：定义清除缓存，触发缓存清除</li><li>@Caching：组合定义多种缓存功能</li><li>@CacheConfig：定义公共设置，位于class之上</li></ul><p>2.1 @EnableCaching</p><p>该注解主要用于开启基于注解的缓存功能,使用方式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SimpleCacheManager cacheManager = <span class="keyword">new</span> SimpleCacheManager();</span><br><span class="line">        cacheManager.setCaches(Arrays.asList(<span class="keyword">new</span> ConcurrentMapCache(<span class="string">"default"</span>)));</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在SpringBoot中使用SpringCache可以由自动配置功能来完成CacheManager的注册，SpringBoot会自动发现项目中拥有的缓存系统，而注册对应的缓存管理器，当然我们也可以手动指定。</p></blockquote><p>使用该注解和如下XML配置具有一样的效果：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.support.SimpleCacheManager&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">        &lt;property name="</span><span class="attr">caches</span>"&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">                    &lt;property name="</span><span class="attr">name</span>" <span class="attr">value</span>=<span class="string">"default"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面来看看@EnableCaching的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Import</span>(CachingConfigurationSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableCaching</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于设置使用哪种代理方式，默认为基于接口的JDK动态代理（false），</span></span><br><span class="line">    <span class="comment">// 设置为true，则使用基于继承的CGLIB动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">proxyTargetClass</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">// 用于设置切面织入方式(设置面向切面编程的实现方式)，</span></span><br><span class="line">    <span class="comment">// 默认为使用动态代理的方式织入，当然也可以设置为ASPECTJ的方式来实现AOP</span></span><br><span class="line">    <span class="function">AdviceMode <span class="title">mode</span><span class="params">()</span> <span class="keyword">default</span> AdviceMode.PROXY</span>;</span><br><span class="line">    <span class="comment">// 用于设置在一个切点存在多个通知的时候各个通知的执行顺序，默认为最低优先级，</span></span><br><span class="line">    <span class="comment">// 其中数字却大优先级越低，这里默认为最低优先级，int LOWEST_PRECEDENCE =</span></span><br><span class="line">    <span class="comment">// Integer.MAX_VALUE;，却是整数的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">order</span><span class="params">()</span> <span class="keyword">default</span> Ordered.LOWEST_PRECEDENCE</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> AdviceMode &#123;</span><br><span class="line">    PROXY,</span><br><span class="line">    ASPECTJ</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> HIGHEST_PRECEDENCE = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">int</span> LOWEST_PRECEDENCE = Integer.MAX_VALUE;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上面的源码可以看出，缓存功能是依靠AOP来实现的。</p><h4 id="2-2-Cacheable"><a href="#2-2-Cacheable" class="headerlink" title="2.2 @Cacheable"></a>2.2 @Cacheable</h4><p>该注解用于标注于方法之上用于标识该方法的返回结果需要被缓存起来，标注于类之上标识该类中所有方法均需要将结果缓存起来。</p><p>该注解标注的方法每次被调用前都会触发缓存校验，校验指定参数的缓存是否已存在（已发生过相同参数的调用），若存在，直接返回缓存结果，否则执行方法内容，最后将方法执行结果保存到缓存中。</p><p>2.2.1 使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnimalRepository animalRepository;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="comment">//    @Cacheable("animalById")</span></span><br><span class="line">    <span class="meta">@Cacheable</span>(value = <span class="string">"animalById"</span>, key = <span class="string">"#id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Animal&gt; <span class="title">getAnimalById</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(animalRepository.selectById(id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例中两个@Cacheable配置效果其实是一样的，其中value指定的缓存的名称，它和另一个方法cacheName效果一样，一般来说这个缓存名称必须要有，因为这个是区别于其他方法的缓存的唯一方法。</p><p>这里我们介绍一下缓存的简单结构，在缓存中，每个这样的缓存名称的名下都会存在着多个缓存条目，这些缓存条目对应在使用不同的参数调用当前方法时生成的缓存，所有一个缓存名称并不是一个缓存，而是一系列缓存。</p><p>另一个key用于指定当前方法的缓存保存时的键的组合方式，默认的情况下使用所有的参数组合而成，这样可以有效区分不同参数的缓存。当然我们也可以手动指定，指定的方法是使用SPEL表达式。</p><p>这里我么来简单看看其源码，了解下其他几个方法的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Cacheable &#123;</span><br><span class="line">    <span class="comment">// 用于指定缓存名称，与cacheNames()方法效果一致</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 用于指定缓存名称，与value()方法效果一致</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 用于使用SPEL手动指定缓存键的组合方式，默认情况使用所有的参数来组合成键，除非自定义了keyGenerator。</span></span><br><span class="line">    <span class="comment">// 使用SPEL表达式可以根据上下文环境来获取到指定的数据：</span></span><br><span class="line">    <span class="comment">// #root.method：用于获取当前方法的Method实例</span></span><br><span class="line">    <span class="comment">// #root.target：用于获取当前方法的target实例</span></span><br><span class="line">    <span class="comment">// #root.caches：用于获取当前方法关联的缓存</span></span><br><span class="line">    <span class="comment">// #root.methodName：用于获取当前方法的名称</span></span><br><span class="line">    <span class="comment">// #root.targetClass：用于获取目标类类型</span></span><br><span class="line">    <span class="comment">// #root.args[1]：获取当前方法的第二个参数，等同于：#p1和#a1和#argumentName</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 自定义键生成器，定义了该方法之后，上面的key方法自动失效，这个键生成器是：</span></span><br><span class="line">    <span class="comment">// org.springframework.cache.interceptor.KeyGenerator，这是一个函数式接口，</span></span><br><span class="line">    <span class="comment">// 只有一个generate方法，我们可以通过自定义的逻辑来实现自定义的key生成策略。</span></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 用于设置自定义的cacheManager(缓存管理器),可以自动生成一个cacheResolver</span></span><br><span class="line">    <span class="comment">// （缓存解析器），这一下面的cacheResolver()方法设置互斥</span></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 用于设置一个自定义的缓存解析器</span></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 用于设置执行缓存的条件，如果条件不满足，方法返回的结果就不会被缓存，默认无条件全部缓存。</span></span><br><span class="line">    <span class="comment">// 同样使用SPEL来定义条件，可以使用的获取方式同key方法。</span></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 这个用于禁止缓存功能，如果设置的条件满足，就不执行缓存结果，与上面的condition不同之处在于，</span></span><br><span class="line">    <span class="comment">// 该方法执行在当前方法调用结束，结果出来之后，因此，它除了可以使用上面condition所能使用的SPEL</span></span><br><span class="line">    <span class="comment">// 表达式之外，还可以使用#result来获取方法的执行结果，亦即可以根据结果的不同来决定是否缓存。</span></span><br><span class="line">    <span class="function">String <span class="title">unless</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 设置是否对多个针对同一key执行缓存加载的操作的线程进行同步，默认不同步。这个功能需要明确确定所</span></span><br><span class="line">    <span class="comment">// 使用的缓存工具支持该功能，否则不要滥用。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">sync</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如何自定义一个KeyGenerator呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalKeyGenerator</span> <span class="keyword">implements</span> <span class="title">KeyGenerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">generate</span><span class="params">(Object target, Method method, Object... params)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"animal-"</span>);</span><br><span class="line">        sb.append(target.getClass().getSimpleName()).append(<span class="string">"-"</span>).append(method.getName()).append(<span class="string">"-"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : params) &#123;</span><br><span class="line">            String s = o.toString();</span><br><span class="line">            sb.append(s).append(<span class="string">"-"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.deleteCharAt(sb.lastIndexOf(<span class="string">"-"</span>)).toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.3 @CachePut</p><p>该注解用于更新缓存，无论结果是否已经缓存，都会在方法执行结束插入缓存，相当于更新缓存。一般用于更新方法之上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnimalRepository animalRepository;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@CachePut</span>(value = <span class="string">"animalById"</span>, key = <span class="string">"#animal.id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Animal&gt; <span class="title">updateAnimal</span><span class="params">(<span class="keyword">final</span> Animal animal)</span></span>&#123;</span><br><span class="line">        Wrapper&lt;Animal&gt; animalWrapper = <span class="keyword">new</span> UpdateWrapper&lt;&gt;();</span><br><span class="line">        ((UpdateWrapper&lt;Animal&gt;) animalWrapper).eq(<span class="string">"id"</span>,animal.getId());</span><br><span class="line">        animalRepository.update(animal, animalWrapper);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(<span class="keyword">this</span>.getAnimalById(animal.getId()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定更新缓存，value同样还是缓存名称，这里更新的是上面查询操作的同一缓存，而且key设置为id也与上面的key设置对应。</p><p>如此设置之后，每次执行update方法时都会直接执行方法内容，然后将返回的结果保存到缓存中，如果存在相同的key,直接替换缓存内容执行缓存更新。</p><p>下面来看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CachePut &#123;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">unless</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一点要注意：这里的设置一定要和执行缓存保存的方法的@Cacheable的设置一致，否则无法准确更新。</p><h4 id="2-4-CacheEvict"><a href="#2-4-CacheEvict" class="headerlink" title="2.4 @CacheEvict"></a>2.4 @CacheEvict</h4><p>该注解主要用于删除缓存操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnimalRepository animalRepository;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@CacheEvict</span>(value = <span class="string">"animalById"</span>, key = <span class="string">"#id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">deleteAnimalById</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(animalRepository.deleteById(id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单明了，看看源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheEvict &#123;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"cacheNames"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 同上</span></span><br><span class="line">    <span class="function">String <span class="title">condition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 这个设置用于指定当前缓存名称名下的所有缓存是否全部删除，默认false。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allEntries</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="comment">// 这个用于指定删除缓存的操作是否在方法调用之前完成，默认为false，表示先调用方法，在执行缓存删除。</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">beforeInvocation</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-Caching"><a href="#2-5-Caching" class="headerlink" title="2.5 @Caching"></a>2.5 @Caching</h4><p>这个注解用于组个多个缓存操作，包括针对不用缓存名称的相同操作等，源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Caching &#123;</span><br><span class="line">    <span class="comment">// 用于指定多个缓存设置操作</span></span><br><span class="line">    Cacheable[] cacheable() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 用于指定多个缓存更新操作</span></span><br><span class="line">    CachePut[] put() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 用于指定多个缓存失效操作</span></span><br><span class="line">    CacheEvict[] evict() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AnimalRepository animalRepository;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="meta">@Caching</span>(</span><br><span class="line">        evict = &#123;</span><br><span class="line">            <span class="meta">@CacheEvict</span>(value = <span class="string">"animalById"</span>, key = <span class="string">"#id"</span>),</span><br><span class="line">            <span class="meta">@CacheEvict</span>(value = <span class="string">"animals"</span>, allEntries = <span class="keyword">true</span>, beforeInvocation = <span class="keyword">true</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Integer&gt; <span class="title">deleteAnimalById</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok(animalRepository.deleteById(id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Cacheable</span>(<span class="string">"animals"</span>)</span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;Page&lt;Animal&gt;&gt; getAnimalPage(<span class="keyword">final</span> Animal animal, <span class="keyword">final</span> <span class="keyword">int</span> pageId, <span class="keyword">final</span> <span class="keyword">int</span> pageSize)&#123;</span><br><span class="line">        Page&lt;Animal&gt; page = <span class="keyword">new</span> Page&lt;&gt;();</span><br><span class="line">        page.setCurrent(pageId);</span><br><span class="line">        page.setSize(pageSize);</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok((Page&lt;Animal&gt;) animalRepository.selectPage(page,packWrapper(animal, WrapperType.QUERY)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-CacheConfig"><a href="#2-6-CacheConfig" class="headerlink" title="2.6 @CacheConfig"></a>2.6 @CacheConfig</h4><p>该注解标注于类之上，用于进行一些公共的缓存相关配置。源码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CacheConfig &#123;</span><br><span class="line">    <span class="comment">// 设置统一的缓存名，适用于整个类中的方法全部是针对同一缓存名操作的情况</span></span><br><span class="line">    String[] cacheNames() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 设置统一个键生成器，免去了每个缓存设置中单独设置</span></span><br><span class="line">    <span class="function">String <span class="title">keyGenerator</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 设置统一个自定义缓存管理器</span></span><br><span class="line">    <span class="function">String <span class="title">cacheManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">    <span class="comment">// 设置统一个自定义缓存解析器</span></span><br><span class="line">    <span class="function">String <span class="title">cacheResolver</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转载于<a href="https://www.jianshu.com/p/6db623355e11" target="_blank" rel="noopener">SpringBoot基础系列-SpringCache使用</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;headerlink&quot; title=&quot;一、概述&quot;&gt;&lt;/a&gt;一、概述&lt;/h2&gt;&lt;p&gt;SpringCache本身是一个缓存体系的抽象实现，并没有具体的缓存能力，要使用SpringCache还需要配合具体的缓存实
      
    
    </summary>
    
    
      <category term="工具" scheme="http://abc.16home.top/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="缓存" scheme="http://abc.16home.top/categories/%E5%B7%A5%E5%85%B7/%E7%BC%93%E5%AD%98/"/>
    
    
      <category term="SpringBoot" scheme="http://abc.16home.top/tags/SpringBoot/"/>
    
      <category term="缓存" scheme="http://abc.16home.top/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
</feed>
